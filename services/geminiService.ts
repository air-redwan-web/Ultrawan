
import { GoogleGenAI } from "@google/genai";
import { SYSTEM_INSTRUCTION } from "../constants.ts";
import { ChatMessage, Role, AppMode } from "../types.ts";

export interface StreamYield {
  text?: string;
  sources?: { uri: string; title: string }[];
  status?: 'thinking' | 'searching' | 'none';
}

export class GeminiService {
  private formatMessages(history: ChatMessage[]) {
    return history.map(msg => {
      const parts: any[] = [{ text: msg.content || ' ' }];
      if (msg.media) {
        parts.push({
          inlineData: {
            mimeType: msg.media.mimeType,
            data: msg.media.data
          }
        });
      }
      return {
        role: msg.role === Role.USER ? 'user' : 'model',
        parts: parts
      };
    });
  }

  async generateImage(prompt: string, sourceImage?: { data: string; mimeType: string }): Promise<{ data: string; mimeType: string; text?: string }> {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    
    const parts: any[] = [{ text: prompt }];
    if (sourceImage) {
      parts.push({
        inlineData: {
          data: sourceImage.data,
          mimeType: sourceImage.mimeType
        }
      });
    }

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image',
      contents: {
        parts: parts,
      },
      config: {
        imageConfig: {
          aspectRatio: "1:1"
        }
      }
    });

    let imageData: { data: string; mimeType: string } | null = null;
    let textOutput = "";

    for (const part of response.candidates[0].content.parts) {
      if (part.inlineData) {
        imageData = {
          data: part.inlineData.data,
          mimeType: part.inlineData.mimeType
        };
      } else if (part.text) {
        textOutput += part.text;
      }
    }

    if (!imageData) {
      throw new Error("No image was generated by the model.");
    }

    return { ...imageData, text: textOutput };
  }

  async *streamResponse(history: ChatMessage[], mode: AppMode = 'Standard'): AsyncGenerator<StreamYield> {
    const contents = this.formatMessages(history);

    try {
      const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
      
      const modelName = (mode === 'Engineering' || mode === 'Math' || mode === 'Search' || mode === 'Thinking' || mode === 'Research' || mode === 'Shopping') 
        ? 'gemini-3-pro-preview' 
        : 'gemini-3-flash-preview';

      const config: any = {
        systemInstruction: SYSTEM_INSTRUCTION + `\n\nCurrent active mode: ${mode}.\nData Goal: HIGH-DENSITY INSTITUTIONAL DATA. Always find unique IDs (EIIN, EMIS, Reg).`,
        temperature: (mode === 'Engineering' || mode === 'Thinking') ? 0.2 : 0.6,
      };

      if (modelName === 'gemini-3-pro-preview') {
        config.thinkingConfig = { thinkingBudget: (mode === 'Search' || mode === 'Research') ? 3000 : 4000 }; 
      } else {
        config.thinkingConfig = { thinkingBudget: 0 };
      }

      if (mode === 'Search' || mode === 'Research' || mode === 'Shopping') {
        config.tools = [{ googleSearch: {} }];
        yield { status: 'searching' };
      }

      const result = await ai.models.generateContentStream({
        model: modelName,
        contents: contents,
        config: config,
      });

      let hasStartedText = false;

      for await (const chunk of result) {
        if (!hasStartedText && modelName === 'gemini-3-pro-preview' && !(mode === 'Search' || mode === 'Research' || mode === 'Shopping')) {
          yield { status: 'thinking' };
        }

        if (chunk.text) {
          hasStartedText = true;
          yield { text: chunk.text, status: 'none' };
        }
        
        const groundingMetadata = chunk.candidates?.[0]?.groundingMetadata;
        if (groundingMetadata?.groundingChunks) {
          const sources = groundingMetadata.groundingChunks
            .filter((c: any) => c.web)
            .map((c: any) => ({
              uri: c.web.uri,
              title: c.web.title
            }));
          if (sources.length > 0) yield { sources };
        }
      }
    } catch (error) {
      console.error("Ultrawan Logic Error:", error);
      throw error;
    }
  }
}

export const gemini = new GeminiService();
